package org.streampipes.rest.impl.connect;



import org.eclipse.rdf4j.repository.RepositoryException;
import org.eclipse.rdf4j.rio.RDFParseException;
import org.streampipes.config.backend.BackendConfig;
import org.streampipes.connect.RunningAdapterInstances;
import org.streampipes.connect.firstconnector.protocol.stream.KafkaProtocol;
import org.streampipes.container.html.JSONGenerator;
import org.streampipes.container.html.model.DataSourceDescriptionHtml;
import org.streampipes.container.html.model.Description;
import org.streampipes.connect.firstconnector.Adapter;
import org.streampipes.connect.firstconnector.format.csv.CsvFormat;
import org.streampipes.connect.firstconnector.format.json.JsonFormat;
import org.streampipes.connect.firstconnector.protocol.set.FileProtocol;
import org.streampipes.connect.firstconnector.protocol.set.HttpProtocol;
import org.streampipes.container.transform.Transformer;
import org.streampipes.container.util.Util;
import org.streampipes.model.SpDataSet;
import org.streampipes.model.SpDataStream;
import org.streampipes.model.graph.DataSourceDescription;
import org.streampipes.model.grounding.EventGrounding;
import org.streampipes.model.modelconnect.*;
import org.streampipes.rest.annotation.GsonWithIds;
import org.streampipes.rest.impl.AbstractRestInterface;

import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.*;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.streampipes.sdk.helpers.SupportedFormats;
import org.streampipes.sdk.helpers.SupportedProtocols;
import org.streampipes.serializers.jsonld.JsonLdTransformer;
import org.streampipes.storage.couchdb.impl.AdapterStorageImpl;
import org.streampipes.vocabulary.StreamPipes;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

@Path("/v2/adapter")
public class SpConnect extends AbstractRestInterface {

    Logger logger = LoggerFactory.getLogger(SpConnect.class);


    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/allProtocols")
    public Response getAllProtocols() {
        ProtocolDescriptionList pdl = new ProtocolDescriptionList();
        pdl.addDesctiption(new HttpProtocol().declareModel());
        pdl.addDesctiption(new FileProtocol().declareModel());
        pdl.addDesctiption(new KafkaProtocol().declareModel());

        return ok(JsonLdUtils.toJsonLD(pdl));
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/allFormats")
    public Response getAllFormats() {
        FormatDescriptionList fdl = new FormatDescriptionList();
        fdl.addDesctiption(new JsonFormat().declareModel());
        fdl.addDesctiption(new CsvFormat().declareModel());

        return ok(JsonLdUtils.toJsonLD(fdl));
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @GsonWithIds
    @Path("/all")
    public Response getAllAdapters() {
        String host = BackendConfig.INSTANCE.getBackendHost() + ":" + BackendConfig.INSTANCE.getBackendPort();

        List<AdapterDescription> allAdapters = new AdapterStorageImpl().getAllAdapters();
        List<Description> allAdapterDescriptions = new ArrayList<>();

        for (AdapterDescription ad : allAdapters) {
            URI uri = null;
            try {
                uri = new URI("http://" + host + "/streampipes-backend/api/v2/adapter/all/" + ad.getId());
            } catch (URISyntaxException e) {
                e.printStackTrace();
            }
            List<Description> streams = new ArrayList<>();
            Description d = new Description(ad.getName(), "", uri);
            d.setType("set");
            streams.add(d);
            DataSourceDescriptionHtml dsd = new DataSourceDescriptionHtml("Adapter Stream",
                    "This stream is generated by an StreamPipes Connect adapter. ID of adapter: " + ad.getId(), uri, streams);
            dsd.setType("source");
            allAdapterDescriptions.add(dsd);
        }

        JSONGenerator json = new JSONGenerator(allAdapterDescriptions);

        return ok(json.buildJson());
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("/all/{id}")
    public Response getAdapter(@Context HttpServletRequest request, @PathParam("id") String id) {

        AdapterDescription adapterDescription = new AdapterStorageImpl().getAdapter(id);

        SpDataStream ds = null;
        if (adapterDescription instanceof AdapterSetDescription) {
            ds = ((AdapterSetDescription) adapterDescription).getDataSet();
            EventGrounding eg = new EventGrounding();
            eg.setTransportProtocol(SupportedProtocols.kafka());
            eg.setTransportFormats(Arrays.asList(SupportedFormats.jsonFormat()));
            ((SpDataSet) ds).setSupportedGrounding(eg);
        } else {
            ds = ((AdapterStreamDescription) adapterDescription).getDataStream();
        }


        String url = request.getRequestURL().toString();

        ds.setName(adapterDescription.getName());
        ds.setDescription("Description");

//        dataSet.setUri(url);
        ds.setUri(url + "/streams");

        DataSourceDescription dataSourceDescription = new DataSourceDescription(
                url, "Adaper Data Source",
                "This data source contains one data stream from the adapters");

        dataSourceDescription.addEventStream(ds);

        return ok(JsonLdUtils.toJsonLD(dataSourceDescription));
    }

    @POST
    @Path("/all/{streamId}/streams")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public String invokeAdapter(@PathParam("streamId") String streamId, String
            payload) {

        try {
            SpDataSet dataSet = Transformer.fromJsonLd(SpDataSet.class, payload, StreamPipes.DATA_SET);
            String runningInstanceId = dataSet.getDatasetInvocationId();

            String brokerUrl = dataSet.getEventGrounding().getTransportProtocol().getBrokerHostname() + ":9092";
            String topic = dataSet.getEventGrounding().getTransportProtocol().getTopicDefinition()
                    .getActualTopicName();


            AdapterDescription adapterDescription = new AdapterStorageImpl().getAdapter(streamId);
            Adapter adapter = new Adapter(brokerUrl, topic, false);

            RunningAdapterInstances.INSTANCE.addAdapter(dataSet.getDatasetInvocationId(), adapter);

            adapter.run(adapterDescription);


            // TODO think of what happens when finished
//            RunningDatasetInstances.INSTANCE.add(runningInstanceId, dataSet, (DataSetDeclarer) streamDeclarer.get().getClass().newInstance());
//            boolean success = RunningDatasetInstances.INSTANCE.getInvocation(runningInstanceId).invokeRuntime(dataSet, ()
//                    -> {
//               //  TODO notify
//            });


            return Util.toResponseString(new org.streampipes.model.Response(runningInstanceId, true));
        } catch (RDFParseException | RepositoryException | IOException
                e) {
            e.printStackTrace();
            return Util.toResponseString(new org.streampipes.model.Response("", false, e.getMessage()));
        }
    }


    @DELETE
    @Path("/all/{streamId}/streams/{runningInstanceId}")
    @Produces(MediaType.APPLICATION_JSON)
    public String detach(@PathParam("streamId") String elementId, @PathParam("runningInstanceId") String runningInstanceId) {

        Adapter adapter = RunningAdapterInstances.INSTANCE.removeAdapter(runningInstanceId);

        if (adapter != null) {
            adapter.stop();

            org.streampipes.model.Response resp = new org.streampipes.model.Response("", true);
            return Util.toResponseString(resp);
        }

        return Util.toResponseString(elementId, false, "Could not find the running instance with id: " + runningInstanceId);
    }


    @POST
    @Produces(MediaType.APPLICATION_JSON)
    public Response addAdapter(String ar) {


        JsonLdTransformer jsonLdTransformer = new JsonLdTransformer();

        AdapterDescription a = null;

        try {
            if (ar.contains("AdapterSetDescription")){
                a = jsonLdTransformer.fromJsonLd(ar, AdapterSetDescription.class);
            } else {
                a = jsonLdTransformer.fromJsonLd(ar, AdapterStreamDescription.class);
            }

            logger.info("Add Adapter Description " + a.getId());
        } catch (IOException e) {
            logger.error("" + a.getId());
            e.printStackTrace();
        }

        new AdapterStorageImpl().storeAdapter(a);


        //ADD HERE if Stream Adapter start it in a Thread


        return Response.ok().build();
    }


    @DELETE
    @Produces(MediaType.APPLICATION_JSON)
    @Path("{adapterId}")
    public Response deleteAdapter(@PathParam("adapterId") String adapterId) {

        new AdapterStorageImpl().delete(adapterId);

        return Response.ok().build();
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @GsonWithIds
    @Path("/allrunning")
    public Response getAllRunningAdapters() {

        AdapterDescriptionList adapterDescriptionList = new AdapterDescriptionList();

        List<AdapterDescription> allAdapters = new AdapterStorageImpl().getAllAdapters();
        adapterDescriptionList.setList(allAdapters);

        for(AdapterDescription ad : adapterDescriptionList.getList()) {
            ad.setUri("https://www.streampipes.org/adapter/" + UUID.randomUUID());
        }

        return ok(JsonLdUtils.toJsonLD(adapterDescriptionList));
    }


}
